//ff-c++ -auto overthrust.cpp
//ff-mpirun -np 4 Navier-3d-overthrust.edp -glut ffglut -raspart -ffddm_schwarz_method ras

include "cube.idp"

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "overthrust"

macro def(i)[i,i#B,i#C]// EOM                         // scalar field definition
macro init(i)[i,i,i]// EOM                        // scalar field initialization
func Pk = [P1,P1,P1];  

//Overthrust Ovt("/Users/pn/3DOverthrustdata.bin");

real freq = getARGV("-frequency",0.3); // Hz
real k = 2.*pi*freq;
real k0 = 2.*pi*freq;
real lambda0 = 1.5*0.32319/freq;
real omega = 2*pi*freq;

real Q = 0;

real a0=0.7858,a1=-1.2344,a2=0.7949,a3=-0.1238,a4=0.0064;
real b1=1.6612,b2=-0.4721,b3=0.0671,b4=-0.0043,b5=0.000106;

func Cp = 1;//Ovt(x,y,z);  // km/s
func Cs = 1;//a0+a1*Cp+a2*Cp^2+a3*Cp^3+a4*Cp^4;  // km/s
func rho = 1;//b1*Cp+b2*Cp^2+b3*Cp^3+b4*Cp^4+b5*Cp^5;
func lambda = -2*Cs^2*rho+Cp^2*rho;
func mu = Cs^2*rho;
func Kp = omega/Cp;
func Ks = Kp*Cp/Cs;					    // wavenumber of P & S-waves

real length = 20;
real depth = 4.65;

real xs = length/2.;
real ys = length/2.;
real zs = 0;

func source = exp(-200*((x-xs)^2+(y-ys)^2+(z-zs)^2));  // source at the top surface

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int labextxm = 11;
int labextxM = 12;
int labextym = 13;
int labextyM = 14;
int labextzm = 15;
int labextzM = 16;

int[int] labsext = [labextxm,labextxM,labextym,labextyM,labextzm,labextzM];

int mysplit = 2;

real npplo = 10./mysplit;

int nloc = npplo*length/lambda0/mysplit;

int[int] NN=[nloc,nloc,nloc*depth/length];
real [int,int] BB=[[0,length],[0,length],[-depth,0]];
int [int,int] L=[[labextxm,labextxM],[labextym,labextyM],[labextzm,labextzM]];
mesh3 Thc = Cube(NN,BB,L);

mesh3 Th = trunc(Thc,1,split=mysplit);

real sqrt2 = sqrt(2.);
macro Grad(u) [dx(u),dy(u),dz(u)]              // EOM
macro epsilon(u,v,w) [dx(u),dy(v),dz(w),(dy(u)+dx(v))/sqrt2,(dx(w)+dz(u))/sqrt2,(dy(w)+dz(v))/sqrt2] // EOM
macro div(u,v,w) ( dx(u)+dy(v)+dz(w) )                              // EOM
// Sigma macro
macro sxx() rho*omega*(Cp*N.x^2+Cs*N.y^2) //EOM
macro sxy() rho*omega*(Cp-Cs)*N.x*N.y     //EOM
macro syy() rho*omega*(Cp*N.y^2+Cs*N.x^2) //EOM
						
macro Navier(u,v,w,uu,vv,ww) rho*omega^2*(u*uu+v*vv+w*ww) 
-lambda*(div(u,v,w)*div(uu,vv,ww))-2.*mu*( epsilon(u,v,w)'*epsilon(uu,vv,ww) ) // EOM
            
macro NavierEprec(u,v,w,uu,vv,ww) rho*(omega^2+1.i*omega)*(u*uu+v*vv+w*ww) 
-lambda*(div(u,v,w)*div(uu,vv,ww))-2.*mu*( epsilon(u,v,w)'*epsilon(uu,vv,ww) ) // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName([u,v,w],[uu,vv,ww]) = int3d(meshName)(Navier(u,v,w,uu,vv,ww)) 
              + int2d(meshName,labsext)(1i * (lambda+2*mu)*Kp*([u,v,w]'*[N.x,N.y,N.z])*([uu,vv,ww]'*[N.x,N.y,N.z]) );
// EOM

// for the preconditioner (if (!bAbsorp) epsilonEprec = epsilonprob;)
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([u,v,w],[uu,vv,ww]) = int3d(meshName)(Navier(u,v,w,uu,vv,ww))
              + int2d(meshName,labsext)(1i * (lambda+2*mu)*Kp*([u,v,w]'*[N.x,N.y,N.z])*([uu,vv,ww]'*[N.x,N.y,N.z]) );
// EOM

// for the preconditioner (if (!bAbsorp) epsilonEprec = epsilonprob;) (oras)
macro VarfOpt(varfName, meshName, PhName)
    varf varfName([u,v,w],[uu,vv,ww]) = int3d(meshName)(Navier(u,v,w,uu,vv,ww)) 
              + int2d(meshName,labsext,10)(1i * (lambda+2*mu)*Kp*([u,v,w]'*[N.x,N.y,N.z])*([uu,vv,ww]'*[N.x,N.y,N.z]) );
// EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([u,v,w],[uu,vv,ww]) = 
   			 -intN(meshName)(source*ww);
// EOM

macro Ndefplot(u)sqrt(real(u)^2+real(u#B)^2+real(u#C)^2)//

ffddmbuild(N,Th,complex,def,init,Pk)

ffddmsetup(N,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(N,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

NVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = NfGMRES(x0, rhs, 1.e-6, 200, "right");

Nwritesummary

/*
if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmEuansetup(N,Thc,VarfEprec)

u[] = NfGMRES(x0, rhs, 1.e-6, 200, "right");

Nwritesummary
*/
complex[int] err(u[].n);
err = NA(u[]);
err -= rhs;

ffddmplot(N,u[], "Global solution");
ffddmplot(N,err, "Global residual");

fespace Vhi1(NThi,P1);
Vhi1 solx = real(u);
Vhi1 soly = real(uB);
Vhi1 solz = real(uC);
Vhi1 sol = sqrt(real(u)^2+real(uB)^2+real(uC)^2);

int[int] fforder=[1,1,1,1];
load "iovtk"
savevtk("visu/test_" + mpirank + "_" + mpisize + ".vtk", NThi, solx, soly, solz, sol, dataname = "ux uy uz norm", order = fforder);
exec("/Applications/paraview.app/Contents/bin/pvpython vtk2vtu.py visu/test_" + mpirank + "_" + mpisize);

if(mpirank == 0) {
    ofstream pvd("visu/test.pvd");
    pvd << "<?xml version=\"1.0\"?>\n";
    pvd << "<VTKFile type=\"Collection\" version=\"0.1\"\n";
    pvd << "         byte_order=\"LittleEndian\"\n";
    pvd << "         compressor=\"vtkZLibDataCompressor\">\n";
    pvd << "  <Collection>\n";
    for(int i = 0; i < mpisize; ++i) {
        pvd << "    <DataSet timestep=\"0\" group=\"\" part=\"" << i << "\"\n";
        pvd << "             file=\""; pvd << "test_" << i << "_" << mpisize << ".vtu\"/>\n";
    }   
    pvd << "  </Collection>\n";
    pvd << "</VTKFile>\n";
}
// EOM 




