load "tetgen"

func mesh3 buildMeshWithCavity(int n, real domainwidth, real domaindepth, real domainheight, 
    real obstaclewidth, real obstacleheight, real obstaclethickness, real entranceradius,  
    real localrefinementratio)
{
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    // Cube: width x depth x height 
    // Label: ext    11 left  | 12 right | 13 front  | 14 back  |  15 bottom   | 16 top 
    //        int    55 
    //
    //
    // Configuration: range (min./max. x,y,z) and position, number of points, surface labels
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    int labextxm = 11;
    int labextxM = 12;
    int labextym = 13;
    int labextyM = 14;
    int labextzm = 15;
    int labextzM = 16;
    int labint = 55;
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Cube: width x depth x height 
    real Xmin = -domainwidth/2,    Xmax = domainwidth/2,
        Ymin = -domaindepth/2,    Ymax = domaindepth/2,
        Zmin = -domainheight/2,   Zmax = domainheight/2;
    real xmin = -obstaclewidth/2,  xmax = obstaclewidth/2,
        ymin = -obstacleheight/2, ymax = obstacleheight/2;    
    real  outerradius = obstacleheight/2;
    real  innerradius = obstacleheight/2-obstaclethickness;
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     
    real n0 = n/obstaclewidth;
    int nX = round(n0 * domainwidth  * localrefinementratio);
    int nY = round(n0 * domaindepth  * localrefinementratio);
    int nZ = round(n0 * domainheight * localrefinementratio);
    int nx = round(n0 * obstaclewidth);
    int ny = round(n0 * obstacleheight);
    int nxhole = round(n0*4*obstaclethickness);       nxhole = max(1, nxhole  );
    int nCout  = round(n0*2.*pi* outerradius);      nCout  = max(20, nCout  );
    int nCint  = round(n0*2.*pi* innerradius);      nCint  = max(20, nCint  );
    int nChole = round(n0*2.*pi* entranceradius);   nChole = max(20, nChole  );


    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    mesh ThGround    = square(nX,nY,[Xmin+x*domainwidth, Ymin+y*domaindepth]);
    mesh ThSideWall  = square(nY,nZ,[Ymin+x*domaindepth, Zmin+y*domainheight]);
    mesh ThFrontWall = square(nX,nZ,[Xmin+x*domainwidth, Zmin+y*domainheight]);

    int[int] chlabextxm = [0,labextxm];
    int[int] chlabextxM = [0,labextxM];
    int[int] chlabextym = [0,labextym];
    int[int] chlabextyM = [0,labextyM];
    int[int] chlabextzm = [0,labextzm];
    int[int] chlabextzM = [0,labextzM];
    mesh3 ThExteriorSurface =         
            movemesh23(ThSideWall,  transfo=[Xmin,x,y], orientation=-1,label=chlabextxm)
        +movemesh23(ThSideWall,  transfo=[Xmax,x,y], orientation=-1,label=chlabextxM)
        +movemesh23(ThFrontWall, transfo=[x,Ymin,y], orientation=-1,label=chlabextym)
        +movemesh23(ThFrontWall, transfo=[x,Ymax,y], orientation=-1,label=chlabextyM)
        +movemesh23(ThGround,    transfo=[x,y,Zmin], orientation=-1,label=chlabextzm)
        +movemesh23(ThGround,    transfo=[x,y,Zmax], orientation=-1,label=chlabextzM);
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    int[int] chlabint = [0,labint];
    border diskOutside(t=0,2*pi){x=outerradius*cos(t); y=outerradius*sin(t);label=labint;}
    border diskInside(t=0,2*pi){x=innerradius*cos(t); y=innerradius*sin(t); label=labint;}
    border diskEntrance(t=0,2*pi){x=entranceradius*cos(t); y=entranceradius*sin(t);label=labint;}
    // WALL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    mesh3 obstacleInnerFrontWall = movemesh23(
        square(nx,nCint,[xmin+4*obstaclethickness+x*((xmax-obstaclethickness)-(xmin+4*obstaclethickness)),2*pi*y]),
        transfo=[x,innerradius*cos(y),innerradius*sin(y)],
        orientation=-1,label=chlabint);
    mesh3 obstacleOuterFrontWall = movemesh23(
        square(nx,nCout,[xmin+x*(xmax-xmin),2*pi*y]),
        transfo=[x,outerradius*cos(y),outerradius*sin(y)],
        orientation=-1,label=chlabint);   
    // BOTTOM - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    mesh3 obstacleOuterBottom = movemesh23(buildmesh(diskOutside(nCout)),
        transfo=[xmax,x,y],orientation=-1,label=chlabint);
    mesh3 obstacleInnerBottom = movemesh23(buildmesh(diskInside(nCint)),
        transfo=[xmax-obstaclethickness,x,y],
        orientation=-1,label=chlabint);
    // TOP - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    mesh3 obstacleOuterTop = movemesh23(buildmesh(diskOutside(nCout)+diskEntrance(-nChole)),
        transfo=[xmin,x,y],orientation=-1,label=chlabint);
    mesh3 obstacleInnerTop = movemesh23(buildmesh(diskInside(nCint)+diskEntrance(-nChole)),
        transfo=[xmin+4*obstaclethickness,x,y],
        orientation=-1,label=chlabint);    
    mesh3 obstacleRingTop = movemesh23(square(nxhole,nChole,[xmin+x*4*obstaclethickness,2*pi*y]),
        transfo=[x,entranceradius*cos(y),entranceradius*sin(y)],
        orientation=1,label=chlabint);
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    mesh3 ThObstacleSurface = 
        obstacleInnerFrontWall + obstacleOuterFrontWall 
        + obstacleInnerBottom    + obstacleOuterBottom 
        + obstacleInnerTop       + obstacleOuterTop + obstacleRingTop;
    // gluing meshes
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    mesh3 ThSurface= ThExteriorSurface+ThObstacleSurface;   // gluing meshes


    real vol = (n0^-3.)/6.;
    real[int] holes   = [xmax-obstaclethickness/2.,0.,0.];
    real[int] regions = [0.,0.,0.,53,vol];

    mesh3 Th = tetg(ThSurface, switch= "paAAQYY", nbofholes=1,holelist=holes,
                    nbofregions = 1,regionlist=regions);
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *
    return Th;    
}
                        

func mesh3 buildcmesh(int n, real domainwidth, real domaindepth, real domainheight, 
                    real obstaclewidth, real obstacleheight, real obstaclethickness, real localrefinementratio)
{    
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    // Cube: width x depth x height 
    // Label: ext    11 left  | 12 right | 13 front  | 14 back  |  15 bottom   | 16 top 
    //        int    55 
    //
    //
    // Configuration: range (min./max. x,y,z) and position, number of points, surface labels
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    int labextxm = 11;
    int labextxM = 12;
    int labextym = 13;
    int labextyM = 14;
    int labextzm = 15;
    int labextzM = 16;
    int labint = 55;
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    real Xmin = -domainwidth/2,    Xmax = domainwidth/2,
        Ymin = -domaindepth/2,    Ymax = domaindepth/2,
        Zmin = -domainheight/2,   Zmax = domainheight/2;
    real xmin = -obstaclewidth/2,  xmax = obstaclewidth/2,
        ymin = -obstacleheight/2, ymax = obstacleheight/2;    
    real  outerradius = obstacleheight/2;
    real  innerradius = obstacleheight/2-obstaclethickness;
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     
    real n0 = n/obstaclewidth;
    int nX = n0 * domainwidth  * localrefinementratio;
    int nY = n0 * domaindepth  * localrefinementratio;
    int nZ = n0 * domainheight * localrefinementratio;
    int nx = n0 * obstaclewidth;
    int ny = n0 * obstacleheight;
    int nCout = round(n0*2.*pi* outerradius);
    int nCint = round(n0*2.*pi* innerradius);
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    mesh ThGround    = square(nX,nY,[Xmin+x*domainwidth, Ymin+y*domaindepth]);
    mesh ThSideWall  = square(nY,nZ,[Ymin+x*domaindepth, Zmin+y*domainheight]);
    mesh ThFrontWall = square(nX,nZ,[Xmin+x*domainwidth, Zmin+y*domainheight]);

    int[int] chlabextxm = [0,labextxm];
    int[int] chlabextxM = [0,labextxM];
    int[int] chlabextym = [0,labextym];
    int[int] chlabextyM = [0,labextyM];
    int[int] chlabextzm = [0,labextzm];
    int[int] chlabextzM = [0,labextzM];
    mesh3 ThExteriorSurface =         
            movemesh23(ThSideWall,  transfo=[Xmin,x,y], orientation=-1,label=chlabextxm)
        +movemesh23(ThSideWall,  transfo=[Xmax,x,y], orientation=-1,label=chlabextxM)
        +movemesh23(ThFrontWall, transfo=[x,Ymin,y], orientation=-1,label=chlabextym)
        +movemesh23(ThFrontWall, transfo=[x,Ymax,y], orientation=-1,label=chlabextyM)
        +movemesh23(ThGround,    transfo=[x,y,Zmin], orientation=-1,label=chlabextzm)
        +movemesh23(ThGround,    transfo=[x,y,Zmax], orientation=-1,label=chlabextzM);
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    int[int] chlabint = [0,labint];
    border diskOutside(t=0,2*pi){x=outerradius*cos(t); y=outerradius*sin(t);label=labint;}
    border diskInside(t=0,2*pi){x=innerradius*cos(t); y=innerradius*sin(t); label=labint;}
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    mesh3 obstacleRing = movemesh23(buildmesh(diskOutside(nCout)+diskInside(-nCint)),
        transfo=[xmin,x,y],orientation=-1,label=chlabint);
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    mesh3 obstacleInnerFrontWall = movemesh23(
        square(nx,nCint,[xmin+x*(xmax-obstaclethickness-xmin),2*pi*y]),
        transfo=[x,innerradius*cos(y),innerradius*sin(y)],
        orientation=-1,label=chlabint);
    mesh3 obstacleInnerBottom = movemesh23(
        buildmesh(diskInside(nCint)),
        transfo=[xmax-obstaclethickness,x,y],
        orientation=-1,label=chlabint);
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    mesh3 obstacleOuterFrontWall = movemesh23(
        square(nx,nCout,[xmin+x*(xmax-xmin),2*pi*y]),
        transfo=[x,outerradius*cos(y),outerradius*sin(y)],
        orientation=-1,label=chlabint);
    mesh3 obstacleOuterBottom = movemesh23(buildmesh(diskOutside(nCout)),
        transfo=[xmax,x,y],
        orientation=-1,label=chlabint);
    // mesh3 obstacleOuterTop = movemesh23(
    //     buildmesh(diskOutside(nCout)),
    //     transfo=[xmin,x,y],
    //     orientation=-1);
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    mesh3 ThObstacleSurface = 
                    obstacleOuterFrontWall + obstacleOuterBottom
                    + obstacleInnerFrontWall + obstacleInnerBottom
                    + obstacleRing;                           // gluing meshes
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * * 
    mesh3 ThSurface = ThExteriorSurface + ThObstacleSurface;   // gluing meshes
    real vol = (n0^-3.)/6.;
    real[int] holes   = [xmax-obstaclethickness/2.,0.,0.];
    real[int] regions = [0.,0.,0.,53,vol];

    mesh3 Th = tetg(ThSurface, switch= "paAAQYY", nbofholes=1,holelist=holes,
                    nbofregions = 1,regionlist=regions);
    // * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *  * * *
    
    return Th;
}
