//ff-c++ mymsh3.cpp
//ff-mpirun --oversubscribe -np 8 Helmholtz-2d-Cobracavity.edp -glut ffglut -raspart -ffddm_schwarz_method oras -ffddm_medit -frequency 2e+9

load "metis"
load "medit"
load "mymsh3"
load "Element_Mixte3d"
load "qf11to25"

include "getARGV.idp"

macro dimension 2// EOM

include "ffddm_parameters.idp"

include "ffddm.idp"

macro FFCMHISTORY()0//
macro FFCMDEBUG()0//

include "ffcmcg.idp"

searchMethod = 1;

include "cobrameshcavity2d.idp"

/* COBRA cavity paper JCP: EM wave scattering problem from the COBRA cavity
We place a first order absorbing boundary condition a few lambdas away from the cavity boundary. 
The volume of the computational domain is much bigger than the interior cavity region itself.  */

// The long dimension is along x (not the same axes)

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",5.e+9);//17.5e+9;
real k = 2*pi*f/c0;
real lambda = c0/f;

real omega = k;
real c = 1;

// pour regler les dimensions de la boite de calcul autour de la cavite
real distx = 0.2*5*lambda;
real disty = distx;
real distz = distx;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

int labextxm = 11;
int labextxM = 12;
int labextym = 13;
int labextyM = 14;

int[int] labsext = [labextxm,labextxM,labextym,labextyM];
int[int] labsref = [labmetal,labo];
//int[int] labsref = [labmetal,labo,labi];
//int[int] labsref = [54];

macro ROBIN labsext//
macro DIRICHLET labsref//

int regint = 4;
int regext = 5;

real epsilonprob = 0;//0 k k^2;                  // epsilon of the problem
real be = getARGV("-betaEprec",1.); // beta from Euan paper, used in epsilonEprec  
real epsilonEprec = 0;//k^be; 

int mysplit = 2;

int nloc = 20./mysplit*sec3/lambda;

meshN Thc;

buildcobramesh(Thc);

macro mydef(u)u//
macro myinit(u)u//
macro mydefpart(u)u//
macro myinitpart(u)u//

func Pk = P2b;
func PkP0 = P2b;

macro QFORDER() ,qforder=12 //EOM

macro grad(u) [dx(u),dy(u)] // EOM

real theta  = 2.*pi*0./360.;        // 180 or 150
// eta is - the direction of propagation
real[int] eta(2), etaort(2);
eta = [cos(theta),sin(theta)];    // oblique
//eta    = [-1,0,0];    // normal
//etaort = [ 0,1,0];    // not used
    
// plane wave
// y polarization
func uin  = exp(1.i*k*(eta(0)*x+eta(1)*y));
func uinx = 1.i*k*eta(0) * uin;
func uiny = 1.i*k*eta(1) * uin;

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  intN(meshName QFORDER)(-(k^2-1i*epsilonprob)*u*v+grad(u)'*grad(v))
				- intbN(meshName,ROBIN)(1i*k*u*v)
				+ on(DIRICHLET,u=0); // EOM

// for the preconditioner (if (!bAbsorp) epsilonEprec = epsilonprob;)
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) = intN(meshName QFORDER)(-(k^2-1i*epsilonEprec)*u*v+grad(u)'*grad(v))
				- intbN(meshName,ROBIN)(1i*k*u*v)
				+ on(DIRICHLET,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) = intN(meshName QFORDER)(-(k^2-1i*epsilonEprec)*u*v+grad(u)'*grad(v))
				- intbN(meshName,ROBIN,10)(1i*k*u*v)
				+ on(DIRICHLET,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) = intbN(meshName,labextxm QFORDER)(v*(1i*k*uin+uinx))
       +intbN(meshName,labextxM)(v*(1i*k*uin-uinx))
       +intbN(meshName,labextym)(v*(1i*k*uin+uiny))
       +intbN(meshName,labextyM)(v*(1i*k*uin-uiny))
       + on(DIRICHLET,u=0);         
    // EOM

macro Mdefplot(u)(real(u))//

vsym = 1;
vtgv = 1.e+30;
vtgvelim = -2;

ffddmbuildtwolevelEdge(M,Thc,mysplit,complex,mydef,myinit,Pk,mydefpart,myinitpart,PkP0,mpiCommWorld)

//macro Mwithhpddmkrylov()1//
//macro MCoarsewithhpddm()1//

//////////////////

ffddmbuildEdge(,Thc,complex,mydef,myinit,Pk,mydefpart,myinitpart,PkP0,mpiCommWorld)

macro ffcmcgrestrictionIntersection(pr)
    real[int] pr#Dpart = pr#D[mpiRank(pr#commddm)];
    int[int][int] pr#cmcgrestrictionIntersectionhpddm(pr#numberIntersection);
    {
        for(int j=0;j<pr#numberIntersection;++j){              
            pr#K[int] C(1);
            int[int] I(1), J(1);
            [I, J, C] = pr#restrictionIntersection[j];
            if (C[C.n-1] == 0) {
                I.resize(C.n-1);
                J.resize(C.n-1);
                C.resize(C.n-1);
            }
            pr#cmcgrestrictionIntersectionhpddm[j].resize(J.n);  
            pr#cmcgrestrictionIntersectionhpddm[j] = J;  
        }       
    }
// EOM    
ffcmcgrestrictionIntersection()
Vhi fpart;
fpart[] = Dpart;
meshN ThAugmented = Thi + aThborder[mpiRank(commddm)];
//   ----------------------------------------------------------------------------------------------
// Wave  - - - - - - - - - - - - - - - - - - - -
macro Varfstiffness(stiffness, meshName )
    varf stiffness (u, v) = intN(meshName QFORDER)(c^2*grad(u)'*grad(v)) + on(DIRICHLET, u=0); 
// EOM

macro Varfmass(mass, meshName ) 
    varf mass (u, v) = intN(meshName QFORDER)( u * v) + on(DIRICHLET, u=0);
// EOM

macro Varfmassonboundary(massonboundary, meshName ) 
    varf massonboundary(u,v) = intbN(meshName, ROBIN QFORDER)(c * u*v) + on(DIRICHLET, u=0);
// EOM                                              

macro Varfloadvector(loadvector, meshName ) 
    varf loadvector(u,v) = intbN(meshName,labextxm QFORDER)(v*(1i*omega*uin+c*uinx))
       +intbN(meshName,labextxM QFORDER)(v*(1i*omega*uin-c*uinx))
       +intbN(meshName,labextym QFORDER)(v*(1i*omega*uin+c*uiny))
       +intbN(meshName,labextyM QFORDER)(v*(1i*omega*uin-c*uiny))
       + on(DIRICHLET,u=0); 
// EOM

macro compatibilitycondition(mu,solution,partition,localmesh)
/*
        complex loceta = (  intN(localmesh QFORDER) (k^2*partition) + 1i*intbN(localmesh, ROBIN QFORDER) (k*partition));
        complex eta = 0;
        mpiAllReduce(loceta,eta,commddm,mpiSUM);
        complex locmu  = (- intN(localmesh QFORDER)  (  k^2*solution*partition) 
                -intbN(localmesh, ROBIN QFORDER) ( 1i*k*solution*partition)
                -(
                     intbN(localmesh,labextxm QFORDER)(1i*omega*uin+c*uinx)
                    +intbN(localmesh,labextxM QFORDER)(1i*omega*uin-c*uinx)
                    +intbN(localmesh,labextym QFORDER)(1i*omega*uin+c*uiny)
                    +intbN(localmesh,labextyM QFORDER)(1i*omega*uin-c*uiny)                
                ))/eta;
                
                
        mpiAllReduce(locmu,mu,commddm,mpiSUM);
*/
   ;   
// EOM
    
   
real CFL = 0.05;                                             // CFL condition
real T   = 2.*pi/omega;                                      // final time  
real ffcmcgtol     = 1e-2;                                  // cg tolerance: relres <= cgtol
real ffcmddmtol    = 1e-5;                                  // gmres tolerance: relres <= cgtol
int  ffcmcgmaxiter = 50;                                  // maximum number of iterations
real ffcmcgddmgeneonu = getARGV("-ffcmcg_hpddm_nu", 10.);

Vhi<K>  ucmcg;                                              // CM-CG solution
ucmcg[] = 0;

complex[int] Mrhs(1);

ffcmcgsetup(Vhi,Thi,omega,c,T,CFL)

int ntotal = Ndofglobal;

//////////////////

int cpt = 0;

ffddmsetup(MCoarse,VarfEprec,VarfOpt)

ffddmsetup(M,Varf,VarfOpt)

ffddmEuansetup(M,Thc,VarfEprec,VarfEprec)

complex[int] rhs(1);

ffddmbuildrhs(M,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

MVhi<complex> mydef(u);

if (mpirank == 0) cout << "ORAS :" << endl;

//u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL + INEXACT COARSE SOLVE :" << endl;

ffddmset(M,corr,"ADEF1")

ffddmset(MCoarse,corr,"test")
ffddmset(MCoarse,verbosity,10)

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

if (mpirank == 0) cout << "fine problem :" << endl;
Mwritesummary
if (mpirank == 0)cout << endl << "coarse problem :" << endl;
MCoarsewritesummary

ffddmplot(M,u[], "Global solution");
